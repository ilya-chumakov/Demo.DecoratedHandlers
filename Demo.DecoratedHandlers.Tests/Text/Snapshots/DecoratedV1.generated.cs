using System;
using System.Threading;
using System.Threading.Tasks;
using Demo.DecoratedHandlers.Abstractions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Demo.DecoratedHandlers.Gen;

// <auto-generated
namespace Demo.DecoratedHandlers.Tests.Text.Snapshots
{ 
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Demo.DecoratedHandlers.Gen", "1.0.0.0")]
    [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Always)]
    
    public class FooHandlerPipeline(IServiceProvider provider) : IGenericHandler<Alpha, Omega>
    { 
        public Task<Omega> HandleAsync(Alpha input, CancellationToken ct = default) 
        {
            var handler = provider.GetRequiredService<FooHandler>(); 
            RequestHandlerDelegate<Omega> original = () => handler.HandleAsync(input, ct);

            var b0 = provider.GetRequiredService<LogBehavior>();
            RequestHandlerDelegate<Omega> f0 = () => b0.Handle(input, original, ct);
            var b1 = provider.GetRequiredService<ExceptionBehavior>();
            RequestHandlerDelegate<Omega> f1 = () => b1.Handle(input, f0, ct);
            return f1();
        }
    } 

    internal static class ServiceCollectionExtensions_FooHandlerPipeline
    {
        [RegisterThis]
        internal static void ReplaceHandlerWithPipeline(this IServiceCollection services)
        {
            services.RemoveAll<IGenericHandler<Alpha, Omega>>();
            services.AddTransient<IGenericHandler<Alpha, Omega>, FooHandlerPipeline>();
            services.AddTransient<FooHandler>();
        }
    }
}