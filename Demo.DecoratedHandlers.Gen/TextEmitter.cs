using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace Demo.DecoratedHandlers.Gen;

public record HandlerDescription(
    string HandlerTypeName,
    string HandlerTypeFullName,
    string InputTypeName,
    string OutputTypeName,
    string ContainingNamespace,
    string PipelineSuffix = "");

public record BehaviorDescription(string TypeName);

public static class TextEmitter
{
    private static readonly AssemblyName EmitterAssemblyName = typeof(TextEmitter).Assembly.GetName();
    private const string NamespacePrefix = "FancyGlobalPrefix"; //todo generate pipeline in its own ns

    public static SourceText CreatePipelineText(
        HandlerDescription handler,
        IReadOnlyList<BehaviorDescription> behaviors)
    {
        // operating over type names everywhere
        string inputType = handler.InputTypeName;
        string outputType = handler.OutputTypeName;
        string typePair = $"{inputType}, {outputType}";
        string handlerType = handler.HandlerTypeFullName;

        string pipelineType = $"{handler.HandlerTypeName}Pipeline{handler.PipelineSuffix}";
        string targetFunc = "original";
        string interfaceType = "InterfaceAlias";
        string delegateType = "DelegateAlias";

        var sb = new StringBuilder(256);
        sb.AppendLine(
            $$"""
              using System;
              using System.Threading;
              using System.Threading.Tasks;
              using Microsoft.Extensions.DependencyInjection;
              using Microsoft.Extensions.DependencyInjection.Extensions;
              
              using Demo.DecoratedHandlers.Abstractions;
              using Demo.DecoratedHandlers.Gen;

              // <auto-generated
              namespace {{handler.ContainingNamespace}};

              using {{interfaceType}} = IRequestHandler<
                  {{inputType}},
                  {{outputType}}>;

              using {{delegateType}} = RequestHandlerDelegate<
                  {{outputType}}>;

              [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{EmitterAssemblyName.Name}}", "{{EmitterAssemblyName.Version}}")]
              [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Always)]

              public class {{pipelineType}}(global::System.IServiceProvider provider) : {{interfaceType}}
              {
                  public Task<{{outputType}}> HandleAsync(
                      {{inputType}} input,
                      CancellationToken ct = default)
                  {
                      var handler = provider.GetRequiredService<
                          {{handlerType}}>(); 

                      {{delegateType}} {{targetFunc}} = () => handler.HandleAsync(input, ct);

              """);

        for (int i = 0; i < behaviors.Count; i++)
        {
            string currentFunc = $"f{i}";
            string currentBehavior = $"b{i}";
            string name = behaviors[i].TypeName;

            sb.AppendLine(
                $"""
                         var {currentBehavior} = provider.GetRequiredService<
                             {name}<
                                 {inputType},
                                 {outputType}>>();

                         {delegateType} {currentFunc} = () => {currentBehavior}.Handle(input, {targetFunc}, ct);

                 """);

            targetFunc = currentFunc;
        }

        sb.Append(
             $$"""
                      return {{targetFunc}}();
                  }
              }

              internal static class ServiceCollectionExtensions_{{pipelineType}}
              {
                  [RegisterThis]
                  internal static void ReplaceHandlerWithPipeline(
                      this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
                  {
                      services.ReplaceWithPipeline<
                          {{interfaceType}},
                          {{handlerType}},
                          {{pipelineType}}>();
                  }
              }
              """);
        return SourceText.From(sb.ToString(), Encoding.UTF8);
    }
}
