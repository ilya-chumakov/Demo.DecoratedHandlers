using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace Demo.DecoratedHandlers.Gen;

public record HandlerDescription(
    string HandlerTypeName,
    string InputTypeName,
    string OutputTypeName,
    string OutputNamespace);

public record BehaviorDescription(string TypeName);

public static class TextEmitter
{
    private static readonly AssemblyName EmitterAssemblyName = typeof(TextEmitter).Assembly.GetName();

    public static SourceText CreatePipelineSource(
        HandlerDescription handler,
        IReadOnlyList<BehaviorDescription> behaviors)
    {
        // operating over type names everywhere
        string inputType = handler.InputTypeName;
        string outputType = handler.OutputTypeName;
        string typePair = $"{inputType}, {outputType}";
        string handlerType = handler.HandlerTypeName;

        string pipelineType = $"{handlerType}Pipeline";
        string targetFunc = "original";
        string delegateType = $"RequestHandlerDelegate<{outputType}>";

        var sb = new StringBuilder(256);
        sb.AppendLine(
            $$"""
              using System;
              using System.Threading;
              using System.Threading.Tasks;
              using Demo.DecoratedHandlers.Abstractions;
              using Microsoft.Extensions.DependencyInjection;
              using Microsoft.Extensions.DependencyInjection.Extensions;
              using Demo.DecoratedHandlers.Gen;

              // <auto-generated
              namespace {{handler.OutputNamespace}}
              { 
                  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{EmitterAssemblyName.Name}}", "{{EmitterAssemblyName.Version}}")]
                  [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Always)]
                  
                  public class {{pipelineType}}(IServiceProvider provider) : IRequestHandler<{{typePair}}>
                  { 
                      public Task<{{outputType}}> HandleAsync({{inputType}} input, CancellationToken ct = default) 
                      {
                          var handler = provider.GetRequiredService<{{handlerType}}>(); 
                          {{delegateType}} {{targetFunc}} = () => handler.HandleAsync(input, ct);
             
              """);

        for (int i = 0; i < behaviors.Count; i++)
        {
            string currentFunc = $"f{i}";
            string currentBehavior = $"b{i}";
            string name = behaviors[i].TypeName;

            sb.AppendLine(
                $"""
                             var {currentBehavior} = provider.GetRequiredService<{name}>();
                             {delegateType} {currentFunc} = () => {currentBehavior}.Handle(input, {targetFunc}, ct);
                 """);

            targetFunc = currentFunc;
        }

        sb.Append(
             $$"""
                          return {{targetFunc}}();
                      }
                  } 

                  internal static class ServiceCollectionExtensions_{{pipelineType}}
                  {
                      [RegisterThis]
                      internal static void ReplaceHandlerWithPipeline(this IServiceCollection services)
                      {
                          services.RemoveAll<IRequestHandler<{{typePair}}>>();
                          services.AddTransient<IRequestHandler<{{typePair}}>, {{pipelineType}}>();
                          services.AddTransient<{{handlerType}}>();
                      }
                  }
              }
              """);
        return SourceText.From(sb.ToString(), Encoding.UTF8);
    }
}
